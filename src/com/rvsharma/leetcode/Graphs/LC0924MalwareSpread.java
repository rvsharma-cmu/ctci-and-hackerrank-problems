package com.rvsharma.leetcode.Graphs;

import java.util.Arrays;

public class LC0924MalwareSpread {

    /*
        Big Idea
        Union find all nodes.
        Count the union size of each disjoint set.
        Count the malware number of each disjoint set.

        Return the biggest disjoint set's malware if there is one and only one malware.

        If no such disjoint set found,
        return the malware with minimum index.
     */
    private int[] parent;

    public int minMalwareSpread(int[][] g, int[] initial) {
        int n = g.length;
        parent = new int[n];
        // initially each node is its own parent
        for (int i = 0; i < n; i++) parent[i] = i;
        // do a union find to find the connected component
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);

        // ufSize for each connected component
        int[] ufSize = new int[n];
        // malware count for each disjoint set
        int[] malCount = new int[n];
        // calculate the disjoint set size for each disjoint set
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        // for each infected node, increment the malware count for that node
        for (int init : initial) malCount[find(init)]++;
        // now find the max uf size that has 1 infected malware count
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }

    private void union(int i, int j) {
        parent[find(i)] = find(j);
    }

    private int find(int i) {
        if (parent[i] == i) return i;
        else {
            parent[i] = find(parent[i]);
            return parent[i];
        }
    }

}
